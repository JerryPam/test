/*
3. Написать класс EasySearch реализующий интерфейс ISearchEngine. Реализовать поиск по строкам при помощи метода indexOf.
В данной реализации запрещено использовать регулярные выражения в любом виде, для любых задач

КОММЕНТАРИЙ
Никак не могу понять, почему в классе EasySearch слова "война" и "мир" находятся на одно меньше, чем в классе RegExSearch...
Возможно не учёл какой-то из символов, которые обрамляют эти слова. Никак не могу взять только в толк - какой.
Или в цикле поиска слова, что-то не до конца докрутил. Тоже пока не могу понять, что. Вроде всё логично сделано.
 */

package HomeWork7_Str;

public class EasySearch implements ISearchEngine{
    public int search(String book, String search_word){
        // В метод передаём слово для поиска в нижнем регистре.
        // Весь текст также приведём в нижний регистр.
        String book_low = book.toLowerCase();

        int count_words = 0; // количество найденных вхождений искомого слова (выражения)
        int num_pos; // номер позиции найденного слова в book

        // проверяем вхождение слова, которое начинается пробелом и
        // оканчивается на пробел ,.!?
        // 
        String str = search_word;
        num_pos = 0;
        //num_pos = book_low.indexOf(str, 0);
        // проверим наличие искомого слова буквально с первой позиции (частный случай)
        // вначале текста возможен вариант, что слово будет прямо с первого символа строки
        // символы подставляем естесственно только справа
        if (book_low.indexOf(str + " ", 0) == 0) count_words = 1;
        else if (book_low.indexOf(str + ",", 0) == 0) count_words = 1;
        else if (book_low.indexOf(str + ".", 0) == 0) count_words = 1;
        else if (book_low.indexOf(str + "!", 0) == 0) count_words = 1;
        else if (book_low.indexOf(str + "?", 0) == 0) count_words = 1;
        else if (book_low.indexOf(str + ":", 0) == 0) count_words = 1;
        else if (book_low.indexOf(str + ";", 0) == 0) count_words = 1;
        //на закрывающую скобку и кавычку в конце искомого слово не проверяю,
        // т.к. при этих символах по логике будет открывающая скобка и кавычка вначале слова, 
        // а это уже проверяется в циклах ниже
        
        // далее проверяем искомое слово уже по всему тексту
        
        char[] first = {' ', '"', '('}; // массив первывых символов для подстановки к слову
        char[] last  = {' ', '.', ',', '!', '?', ')', '"', ':', ';'}; // массив последних символов для подстановки к слову
        
        for(int i = 0; i < first.length; i++) {
            for (int j = 0; j < last.length; j++) {
            str = first[i] + search_word + last[j]; // подставляем предполагаемый первый и последний символы к слову и ищем это сочетание целиком в тексте
            num_pos = 1; // 1, чтобы искали с символа №1, т.к. с символа №0 проверяли вначале, в отдельном условии  (частный случай)
                do {
                    num_pos = book_low.indexOf(str, num_pos);
                    if (num_pos > -1) {
                        count_words++;
                        num_pos = num_pos + str.length(); // определим позицию, с которой будем искать слово далее
                    }
                } while (num_pos < book_low.length() - str.length() & num_pos > -1);
            
            }
        }
        return count_words;
        
    }
     
}
